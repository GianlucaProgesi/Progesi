name: CI (manual)

on:
  workflow_dispatch:
    inputs:
      run_tests:
        description: "Run tests (true/false)"
        required: false
        default: "true"
      collect_coverage:
        description: "Collect coverage (true/false)"
        required: false
        default: "true"

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test:
    runs-on: windows-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            8.0.x
            6.0.x

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-

      # ------------------ TARGET SELECTION ------------------
      - name: Choose build target (prefer .slnf, then .sln)
        shell: pwsh
        run: |
          if (Test-Path 'Progesi.CI.slnf') {
            'CI_BUILD_TARGET=Progesi.CI.slnf' | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host 'Using Progesi.CI.slnf'
          }
          elseif (Test-Path 'Progesi.sln') {
            'CI_BUILD_TARGET=Progesi.sln' | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host 'Using Progesi.sln'
          }
          else {
            'CI_BUILD_TARGET=' | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host 'No .slnf/.sln found -> discovery fallback'
          }

      # ------------------ SOLUTION PATH ------------------
      - name: Restore (solution)
        if: ${{ env.CI_BUILD_TARGET != '' }}
        run: dotnet restore "${{ env.CI_BUILD_TARGET }}"

      - name: Build (solution)
        if: ${{ env.CI_BUILD_TARGET != '' }}
        run: dotnet build "${{ env.CI_BUILD_TARGET }}" -c Release --no-restore /warnaserror

      - name: Test (solution) + optional coverage
        if: ${{ env.CI_BUILD_TARGET != '' && inputs.run_tests == 'true' }}
        shell: pwsh
        run: |
          $collect = ('${{ inputs.collect_coverage }}' -eq 'true')
          $extraArgs = @()
          if ($collect) {
            $extraArgs += '--collect:"XPlat Code Coverage"'
            $extraArgs += '--'
            $extraArgs += 'DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
          }
          dotnet test "${{ env.CI_BUILD_TARGET }}" -c Release --no-build --results-directory TestResults --logger "trx;LogFileName=testresults.trx" $extraArgs

      # ------------------ DISCOVERY FALLBACK ------------------
      - name: Discover SDK-style projects (exclude Rhino/Grasshopper)
        if: ${{ env.CI_BUILD_TARGET == '' }}
        shell: pwsh
        run: |
          $projects = Get-ChildItem -Recurse -Filter *.csproj | Where-Object {
            try {
              $isSdk = (Select-Xml -Path $_.FullName -XPath '/Project/@Sdk').Node
              $notRh = $_.FullName -notmatch 'Rhino|Grasshopper'
              return $isSdk -and $notRh
            } catch { return $false }
          } | Select-Object -ExpandProperty FullName
          if (-not $projects) { throw "Nessun progetto SDK-style trovato." }
          Set-Content buildlist.txt ($projects -join "`n")
          Write-Host "Projects to build:`n$(Get-Content buildlist.txt -Raw)"

      - name: Restore (discover)
        if: ${{ env.CI_BUILD_TARGET == '' }}
        shell: pwsh
        run: |
          Get-Content buildlist.txt | ForEach-Object { dotnet restore $_ }

      - name: Build (discover)
        if: ${{ env.CI_BUILD_TARGET == '' }}
        shell: pwsh
        run: |
          Get-Content buildlist.txt | ForEach-Object { dotnet build $_ -c Release --no-restore /warnaserror }

      - name: Test (discover) + optional coverage
        if: ${{ env.CI_BUILD_TARGET == '' && inputs.run_tests == 'true' }}
        shell: pwsh
        run: |
          $collect = ('${{ inputs.collect_coverage }}' -eq 'true')
          $extraArgs = @()
          if ($collect) {
            $extraArgs += '--collect:"XPlat Code Coverage"'
            $extraArgs += '--'
            $extraArgs += 'DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
          }
          Get-Content buildlist.txt | Where-Object { $_ -match 'Test|\.Tests\\' } | ForEach-Object {
            dotnet test $_ -c Release --no-build --results-directory TestResults --logger "trx;LogFileName=testresults.trx" $extraArgs
          }

      # --- DEBUG: lista file prodotti
      - name: Locate test & coverage files (debug)
        if: always()
        shell: pwsh
        run: |
          Write-Host "=== Listing TestResults ==="
          if (Test-Path TestResults) {
            Get-ChildItem -Recurse TestResults | ForEach-Object { $_.FullName }
          } else {
            Write-Host "No TestResults directory."
          }

      # ------------------ COVERAGE REPORT ------------------
      - name: Generate HTML coverage report (skip if none)
        if: ${{ inputs.collect_coverage == 'true' && inputs.run_tests == 'true' }}
        shell: pwsh
        run: |
          $cov = Get-ChildItem -Recurse -Path "TestResults" -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue
          if (-not $cov) {
            Write-Host "No coverage.cobertura.xml found. Skipping report generation."
            exit 0
          }
          dotnet tool update -g dotnet-reportgenerator-globaltool
          $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
          $reports = ($cov | Select-Object -Expand FullName) -join ';'
          reportgenerator -reports:"$reports" -targetdir:"CoverageReport" -reporttypes:"Html;TextSummary"
          if (Test-Path "CoverageReport/Summary.txt") { Get-Content CoverageReport/Summary.txt }

      - name: Guardrail â€” fail if no tests executed
        if: always() && inputs.run_tests == 'true'
        shell: pwsh
        run: |
          $trx = Get-ChildItem -Recurse -Path "TestResults" -Filter "*.trx" -ErrorAction SilentlyContinue
          if (-not $trx) {
            Write-Error "Nessun file .trx trovato: sembra non siano stati eseguiti test."
          } else {
            Write-Host "Trovati $($trx.Count) file .trx."
          }

      - name: Enforce minimum line coverage
        if: ${{ inputs.collect_coverage == 'true' && inputs.run_tests == 'true' }}
        shell: pwsh
        env:
          MIN_COVERAGE: '75.0'   # alza gradualmente (oggi sei a 60.1)
        run: |
          $summary = 'CoverageReport/Summary.txt'
          if (-not (Test-Path $summary)) {
            Write-Host 'Nessun Summary.txt, salto il controllo soglia.'
            exit 0
          }
          $line = Select-String -Path $summary -Pattern '^  Line coverage:\s+([0-9.]+)%' | Select-Object -First 1
          if (-not $line) { Write-Host 'Riga "Line coverage" non trovata, salto.'; exit 0 }
          $pct = [double]($line.Matches[0].Groups[1].Value)
          $min = [double]$env:MIN_COVERAGE
          Write-Host ("Line coverage: {0}%  â€”  Threshold: {1}%" -f $pct, $min)
          if ($pct -lt $min) { throw "Coverage {0}% < threshold {1}%" -f $pct, $min }

      - name: Coverage summary (job summary)
        if: ${{ inputs.collect_coverage == 'true' && inputs.run_tests == 'true' }}
        shell: pwsh
        run: |
          $summary = 'CoverageReport/Summary.txt'
          if (Test-Path $summary) {
            $sum = Get-Content $summary -Raw
            $sb = New-Object System.Text.StringBuilder
            [void]$sb.AppendLine('### Code Coverage (ReportGenerator)')
            [void]$sb.AppendLine()
            [void]$sb.AppendLine('```')   # apici singoli â‡’ backtick letterali
            [void]$sb.Append($sum)
            [void]$sb.AppendLine()        # aggiungo newline sempre, niente `n
            [void]$sb.AppendLine('```')   # apici singoli
            $sb.ToString() | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          } else {
            Write-Host 'CoverageReport/Summary.txt non trovato: salto il riepilogo.'
          }

      - name: Upload test & coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: TestResults
          path: |
            TestResults/**/*.trx
            TestResults/**/coverage.cobertura.xml
            CoverageReport/**
